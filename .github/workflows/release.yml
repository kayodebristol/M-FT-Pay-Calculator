name: Release

on:
  workflow_dispatch:
    inputs:
      version_bump:
        description: 'Version bump type'
        required: true
        type: choice
        options:
          - patch
          - minor
          - major
        default: patch
      release_notes:
        description: 'Release notes (markdown supported)'
        required: false
        type: string
        default: ''

jobs:
  prepare-release:
    name: Prepare Release
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    
    outputs:
      version: ${{ steps.bump.outputs.version }}
      tag: ${{ steps.bump.outputs.tag }}
      upload_url: ${{ steps.create_release.outputs.upload_url }}
      release_id: ${{ steps.create_release.outputs.id }}
      release_url: ${{ steps.create_release.outputs.url }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
          # Always checkout main branch for releases
          ref: main

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
      - name: Verify we're on main branch
        run: |
          CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
          echo "Current branch: $CURRENT_BRANCH"
          if [ "$CURRENT_BRANCH" != "main" ] && [ "$CURRENT_BRANCH" != "master" ]; then
            echo "‚ö†Ô∏è  Not on main/master, checking out main..."
            git checkout main || git checkout master || {
              echo "‚ùå Failed to checkout main/master branch"
              exit 1
            }
          fi
          echo "‚úÖ On branch: $(git rev-parse --abbrev-ref HEAD)"

      - name: Bump version
        id: bump
        run: |
          # Get current version
          CURRENT_VERSION=$(node -e "const fs=require('fs'); const config=JSON.parse(fs.readFileSync('src-tauri/tauri.conf.json')); console.log(config.version);")
          echo "Current version: $CURRENT_VERSION"
          
          # Bump version (capture output properly)
          node scripts/bump-version.js ${{ github.event.inputs.version_bump }} > bump_output.txt 2>&1
          cat bump_output.txt
          
          # Extract new version from output
          NEW_VERSION=$(grep "New version:" bump_output.txt | awk '{print $3}')
          if [ -z "$NEW_VERSION" ]; then
            echo "‚ùå Failed to extract new version from bump script output"
            cat bump_output.txt
            exit 1
          fi
          
          echo "New version: $NEW_VERSION"
          
          # Set outputs
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "tag=v$NEW_VERSION" >> $GITHUB_OUTPUT
          
          # Verify version was updated
          VERIFIED_VERSION=$(node -e "const fs=require('fs'); const config=JSON.parse(fs.readFileSync('src-tauri/tauri.conf.json')); console.log(config.version);")
          if [ "$VERIFIED_VERSION" != "$NEW_VERSION" ]; then
            echo "‚ùå Version mismatch! Expected $NEW_VERSION but got $VERIFIED_VERSION"
            exit 1
          fi
          
          echo "‚úÖ Version bumped to $NEW_VERSION"

      - name: Create release notes
        id: release_notes
        run: |
          NOTES="${{ github.event.inputs.release_notes }}"
          
          if [ -z "$NOTES" ]; then
            # Generate default release notes from git log
            PREV_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
            if [ -n "$PREV_TAG" ]; then
              NOTES=$(git log ${PREV_TAG}..HEAD --pretty=format:"- %s (%h)" --no-merges)
            else
              NOTES="Initial release"
            fi
          fi
          
          # Add version header
          NOTES="# Release ${{ steps.bump.outputs.tag }}\n\n$NOTES"
          
          # Save to file for later use
          echo -e "$NOTES" > release_notes.md
          
          # Output for GitHub release
          {
            echo 'notes<<EOF'
            echo -e "$NOTES"
            echo 'EOF'
          } >> $GITHUB_OUTPUT
          
          echo "Release notes prepared"
          cat release_notes.md

      - name: Update CHANGELOG
        run: |
          node scripts/update-changelog.js ${{ steps.bump.outputs.version }} release_notes.md
          cat CHANGELOG.md | head -30

      - name: Commit version bump and changelog
        id: commit
        run: |
          git add package.json src-tauri/tauri.conf.json src-tauri/Cargo.toml CHANGELOG.md
          git commit -m "chore: bump version to ${{ steps.bump.outputs.version }}"
          
          # Get the commit SHA
          COMMIT_SHA=$(git rev-parse HEAD)
          echo "commit_sha=$COMMIT_SHA" >> $GITHUB_OUTPUT
          echo "Commit SHA: $COMMIT_SHA"
          
          # Get current branch name
          CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
          echo "Current branch: $CURRENT_BRANCH"
          
          # Push to current branch (should be main)
          git push origin HEAD:$CURRENT_BRANCH || {
            echo "‚ùå Failed to push to $CURRENT_BRANCH"
            exit 1
          }
          
          echo "‚úÖ Pushed version bump commit to $CURRENT_BRANCH"

      - name: Create and push tag
        run: |
          # Create tag pointing to the commit we just pushed
          git tag -a "${{ steps.bump.outputs.tag }}" -m "Release ${{ steps.bump.outputs.tag }}"
          
          # Push tag
          git push origin "${{ steps.bump.outputs.tag }}" || {
            echo "‚ö†Ô∏è  Failed to push tag, retrying..."
            sleep 2
            git push origin "${{ steps.bump.outputs.tag }}"
          }
          
          echo "‚úÖ Tag ${{ steps.bump.outputs.tag }} created and pushed"

      - name: Wait for tag to be available
        run: |
          # Wait a moment for tag to propagate
          sleep 5
          # Verify tag exists
          git fetch --tags
          if git rev-parse "${{ steps.bump.outputs.tag }}" >/dev/null 2>&1; then
            echo "‚úÖ Tag ${{ steps.bump.outputs.tag }} exists"
          else
            echo "‚ö†Ô∏è  Tag not found locally, fetching..."
            git fetch origin tag "${{ steps.bump.outputs.tag }}" || {
              echo "‚ùå Tag ${{ steps.bump.outputs.tag }} not found after fetch"
              exit 1
            }
          fi

      - name: Create GitHub Release
        id: create_release
        uses: softprops/action-gh-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.bump.outputs.tag }}
          name: Release ${{ steps.bump.outputs.tag }}
          body_path: release_notes.md
          draft: false
          prerelease: false
          generate_release_notes: false
          files: |
            CHANGELOG.md

  build-and-release:
    name: Build and Release (${{ matrix.platform }})
    needs: prepare-release
    runs-on: ${{ matrix.os }}
    if: needs.prepare-release.result == 'success'
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: windows-latest
            platform: windows
            target: x86_64-pc-windows-msvc
          - os: macos-latest
            platform: macos
            target: aarch64-apple-darwin
          - os: ubuntu-latest
            platform: linux
            target: x86_64-unknown-linux-gnu
    
    permissions:
      contents: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          # Checkout the tag that was just created
          ref: ${{ needs.prepare-release.outputs.tag }}
          fetch-depth: 0

      - name: Verify tag and version
        run: |
          echo "Tag: ${{ needs.prepare-release.outputs.tag }}"
          echo "Version: ${{ needs.prepare-release.outputs.version }}"
          
          # Verify version in files
          TAURI_VERSION=$(node -e "const fs=require('fs'); const config=JSON.parse(fs.readFileSync('src-tauri/tauri.conf.json')); console.log(config.version);")
          PKG_VERSION=$(node -e "const fs=require('fs'); const pkg=JSON.parse(fs.readFileSync('package.json')); console.log(pkg.version);")
          
          echo "Tauri version: $TAURI_VERSION"
          echo "Package version: $PKG_VERSION"
          
          if [ "$TAURI_VERSION" != "${{ needs.prepare-release.outputs.version }}" ]; then
            echo "‚ùå Version mismatch in tauri.conf.json"
            exit 1
          fi
          
          if [ "$PKG_VERSION" != "${{ needs.prepare-release.outputs.version }}" ]; then
            echo "‚ùå Version mismatch in package.json"
            exit 1
          fi
          
          echo "‚úÖ Version verified"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Install dependencies
        run: npm ci

      - name: Install GitHub CLI
        if: matrix.os != 'windows-latest'
        run: |
          type -p curl >/dev/null || (apt-get update && apt-get install -y curl)
          curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
          chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg
          echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | tee /etc/apt/sources.list.d/github-cli.list > /dev/null
          apt-get update
          apt-get install -y gh

      - name: Install GitHub CLI (Windows)
        if: matrix.os == 'windows-latest'
        run: |
          winget install --id GitHub.cli

      - name: Build application
        run: |
          if [ "${{ matrix.platform }}" == "windows" ]; then
            npm run tauri:build:windows
          elif [ "${{ matrix.platform }}" == "macos" ]; then
            npm run tauri:build:macos
          else
            npm run tauri:build:linux
          fi

      - name: Sign bundles (if configured)
        if: matrix.platform == 'windows' && secrets.WINDOWS_SIGNING_CERTIFICATE != ''
        env:
          WINDOWS_SIGNING_CERTIFICATE: ${{ secrets.WINDOWS_SIGNING_CERTIFICATE }}
          WINDOWS_SIGNING_CERTIFICATE_PASSWORD: ${{ secrets.WINDOWS_SIGNING_CERTIFICATE_PASSWORD }}
        shell: pwsh
        run: |
          $certPath = "$env:RUNNER_TEMP\cert.pfx"
          [System.IO.File]::WriteAllBytes($certPath, [System.Convert]::FromBase64String($env:WINDOWS_SIGNING_CERTIFICATE))
          $env:WINDOWS_SIGNING_CERTIFICATE_PATH = $certPath
          $msiFile = Get-ChildItem -Path "src-tauri\target\**\*.msi" | Select-Object -First 1
          if ($msiFile) {
            pwsh scripts/signing/windows-sign.ps1 -MsiPath $msiFile.FullName
          }

      - name: Sign bundles (macOS)
        if: matrix.platform == 'macos' && secrets.MACOS_SIGNING_CERTIFICATE != ''
        env:
          MACOS_SIGNING_CERTIFICATE: ${{ secrets.MACOS_SIGNING_CERTIFICATE }}
          MACOS_SIGNING_CERTIFICATE_PASSWORD: ${{ secrets.MACOS_SIGNING_CERTIFICATE_PASSWORD }}
        run: |
          # macOS signing would go here
          echo "macOS signing not yet implemented"

      - name: Sign update files
        if: secrets.TAURI_SIGNING_KEY != ''
        env:
          TAURI_SIGNING_KEY: ${{ secrets.TAURI_SIGNING_KEY }}
        run: |
          # Set up signing key
          mkdir -p ~/.tauri
          echo "$TAURI_SIGNING_KEY" | base64 -d > ~/.tauri/myapp.key
          chmod 600 ~/.tauri/myapp.key
          
          # Sign bundles
          bash scripts/sign-update-files.sh || echo "Signing failed, continuing..."

      - name: Find release assets
        id: find_assets
        shell: bash
        run: |
          ASSETS=()
          
          # Find assets based on platform
          if [ "${{ matrix.platform }}" == "windows" ]; then
            while IFS= read -r asset; do
              if [ -f "$asset" ]; then
                ASSETS+=("$asset")
                echo "Found: $asset"
              fi
            done < <(find src-tauri/target -name "*.msi" -o -name "*.msi.sig" 2>/dev/null)
          elif [ "${{ matrix.platform }}" == "macos" ]; then
            while IFS= read -r asset; do
              if [ -f "$asset" ]; then
                ASSETS+=("$asset")
                echo "Found: $asset"
              fi
            done < <(find src-tauri/target \( -name "*.dmg" -o -name "*.app.tar.gz" -o -name "*.dmg.sig" -o -name "*.app.tar.gz.sig" \) 2>/dev/null)
          else
            while IFS= read -r asset; do
              if [ -f "$asset" ]; then
                ASSETS+=("$asset")
                echo "Found: $asset"
              fi
            done < <(find src-tauri/target \( -name "*.deb" -o -name "*.AppImage.tar.gz" -o -name "*.rpm" -o -name "*.deb.sig" -o -name "*.AppImage.tar.gz.sig" -o -name "*.rpm.sig" \) 2>/dev/null)
          fi
          
          if [ ${#ASSETS[@]} -eq 0 ]; then
            echo "‚ö†Ô∏è  No assets found for ${{ matrix.platform }}"
            echo "assets=" >> $GITHUB_OUTPUT
          else
            echo "Found ${#ASSETS[@]} asset(s)"
            printf 'assets=%s\n' "${ASSETS[*]}" >> $GITHUB_OUTPUT
          fi

      - name: Upload release assets
        if: steps.find_assets.outputs.assets != ''
        shell: bash
        run: |
          ASSETS="${{ steps.find_assets.outputs.assets }}"
          for asset in $ASSETS; do
            if [ -f "$asset" ]; then
              echo "Uploading: $asset"
              gh release upload "${{ needs.prepare-release.outputs.tag }}" "$asset" --repo ${{ github.repository }} || {
                echo "‚ö†Ô∏è  Failed to upload $asset, retrying..."
                sleep 2
                gh release upload "${{ needs.prepare-release.outputs.tag }}" "$asset" --repo ${{ github.repository }} || echo "‚ùå Failed to upload $asset after retry"
              }
            fi
          done
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  generate-update-manifest:
    name: Generate Update Manifest
    needs: [prepare-release, build-and-release]
    runs-on: ubuntu-latest
    permissions:
      contents: read
      gists: write
    if: always() && (needs.prepare-release.result == 'success')
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          # Checkout the tag to ensure we have the correct version
          ref: ${{ needs.prepare-release.outputs.tag }}
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install GitHub CLI
        run: |
          type -p curl >/dev/null || apt install curl -y
          curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
          chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg
          echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | tee /etc/apt/sources.list.d/github-cli.list > /dev/null
          apt update
          apt install gh -y

      - name: Get release notes
        id: get_notes
        run: |
          gh release view ${{ needs.prepare-release.outputs.tag }} --repo ${{ github.repository }} --json body --jq '.body' > release_notes.txt || echo "Release ${{ needs.prepare-release.outputs.tag }}" > release_notes.txt
          NOTES=$(cat release_notes.txt)
          echo "notes<<EOF" >> $GITHUB_OUTPUT
          echo "$NOTES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Generate update manifest
        env:
          GITHUB_REPOSITORY: ${{ github.repository }}
          RELEASE_NOTES: ${{ steps.get_notes.outputs.notes }}
        run: |
          node scripts/generate-update-manifest.js latest.json ${{ needs.prepare-release.outputs.version }}
          cat latest.json

      - name: Upload manifest to release
        run: |
          gh release upload "${{ needs.prepare-release.outputs.tag }}" latest.json --repo ${{ github.repository }} --clobber
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create or update Gist with manifest
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          if [ -n "${{ secrets.UPDATE_MANIFEST_GIST_ID }}" ]; then
            echo "Updating existing Gist: ${{ secrets.UPDATE_MANIFEST_GIST_ID }}"
            gh gist edit ${{ secrets.UPDATE_MANIFEST_GIST_ID }} latest.json --filename latest.json || {
              echo "‚ö†Ô∏è  Failed to update Gist, creating new one..."
              GIST_OUTPUT=$(gh gist create latest.json --filename latest.json --public)
              GIST_ID=$(echo "$GIST_OUTPUT" | grep -oP 'gist.github.com/[^/]+/\K[^/]+' || echo "")
              if [ -n "$GIST_ID" ]; then
                echo "‚úÖ Created new Gist: $GIST_ID"
                echo "‚ö†Ô∏è  Update secret UPDATE_MANIFEST_GIST_ID to: $GIST_ID"
              fi
            }
            echo "‚úÖ Updated Gist"
            echo "üìã Manifest URL: https://gist.githubusercontent.com/${{ github.repository_owner }}/${{ secrets.UPDATE_MANIFEST_GIST_ID }}/raw/latest.json"
          else
            echo "Creating new Gist..."
            GIST_OUTPUT=$(gh gist create latest.json --filename latest.json --public)
            GIST_ID=$(echo "$GIST_OUTPUT" | grep -oP 'gist.github.com/[^/]+/\K[^/]+' || echo "")
            if [ -n "$GIST_ID" ]; then
              echo "‚úÖ Created Gist: $GIST_ID"
              echo "üìã Manifest URL: https://gist.githubusercontent.com/${{ github.repository_owner }}/$GIST_ID/raw/latest.json"
              echo ""
              echo "‚ö†Ô∏è  IMPORTANT: Add this to your repository secrets:"
              echo "   Secret name: UPDATE_MANIFEST_GIST_ID"
              echo "   Secret value: $GIST_ID"
            else
              echo "‚ùå Failed to extract Gist ID from output:"
              echo "$GIST_OUTPUT"
            fi
          fi

name: Release

on:
  workflow_dispatch:
    inputs:
      version_bump:
        description: 'Version bump type'
        required: true
        type: choice
        options:
          - patch
          - minor
          - major
        default: patch
      release_notes:
        description: 'Release notes (markdown supported)'
        required: false
        type: string
        default: ''

jobs:
  prepare-release:
    name: Prepare Release
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    
    outputs:
      version: ${{ steps.bump.outputs.version }}
      tag: ${{ steps.bump.outputs.tag }}
      upload_url: ${{ steps.create_release.outputs.upload_url }}
      release_id: ${{ steps.create_release.outputs.id }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Bump version
        id: bump
        run: |
          # Get current version
          CURRENT_VERSION=$(node -e "const fs=require('fs'); const config=JSON.parse(fs.readFileSync('src-tauri/tauri.conf.json')); console.log(config.version);")
          echo "Current version: $CURRENT_VERSION"
          
          # Bump version
          NEW_VERSION=$(node scripts/bump-version.js ${{ github.event.inputs.version_bump }} 2>&1 | grep "New version:" | awk '{print $3}')
          echo "New version: $NEW_VERSION"
          
          # Set outputs
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "tag=v$NEW_VERSION" >> $GITHUB_OUTPUT
          
          # Verify version was updated
          VERIFIED_VERSION=$(node -e "const fs=require('fs'); const config=JSON.parse(fs.readFileSync('src-tauri/tauri.conf.json')); console.log(config.version);")
          if [ "$VERIFIED_VERSION" != "$NEW_VERSION" ]; then
            echo "‚ùå Version mismatch! Expected $NEW_VERSION but got $VERIFIED_VERSION"
            exit 1
          fi
          
          echo "‚úÖ Version bumped to $NEW_VERSION"

      - name: Create release notes
        id: release_notes
        run: |
          NOTES="${{ github.event.inputs.release_notes }}"
          
          if [ -z "$NOTES" ]; then
            # Generate default release notes from git log
            PREV_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
            if [ -n "$PREV_TAG" ]; then
              NOTES=$(git log ${PREV_TAG}..HEAD --pretty=format:"- %s (%h)" --no-merges)
            else
              NOTES="Initial release"
            fi
          fi
          
          # Add version header
          NOTES="# Release ${{ steps.bump.outputs.tag }}\n\n$NOTES"
          
          # Save to file for later use
          echo "$NOTES" > release_notes.md
          
          # Output for GitHub release
          {
            echo 'notes<<EOF'
            echo "$NOTES"
            echo 'EOF'
          } >> $GITHUB_OUTPUT
          
          echo "Release notes prepared"

      - name: Commit version bump
        run: |
          git add package.json src-tauri/tauri.conf.json src-tauri/Cargo.toml
          git commit -m "chore: bump version to ${{ steps.bump.outputs.version }}"
          git push origin HEAD:${{ github.ref_name }}

      - name: Create tag
        run: |
          git tag -a "${{ steps.bump.outputs.tag }}" -m "Release ${{ steps.bump.outputs.tag }}"
          git push origin "${{ steps.bump.outputs.tag }}"

      - name: Create GitHub Release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.bump.outputs.tag }}
          release_name: Release ${{ steps.bump.outputs.tag }}
          body_path: release_notes.md
          draft: false
          prerelease: false

  build-and-release:
    name: Build and Release
    needs: prepare-release
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: windows-latest
            platform: windows
            target: x86_64-pc-windows-msvc
          - os: macos-latest
            platform: macos
            target: aarch64-apple-darwin
          - os: ubuntu-latest
            platform: linux
            target: x86_64-unknown-linux-gnu
    
    permissions:
      contents: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Install dependencies
        run: npm ci

      - name: Install GitHub CLI
        if: matrix.os != 'windows-latest'
        run: |
          type -p curl >/dev/null || (apt-get update && apt-get install -y curl)
          curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
          chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg
          echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | tee /etc/apt/sources.list.d/github-cli.list > /dev/null
          apt-get update
          apt-get install -y gh

      - name: Install GitHub CLI (Windows)
        if: matrix.os == 'windows-latest'
        run: |
          winget install --id GitHub.cli

      - name: Build application
        run: |
          if [ "${{ matrix.platform }}" == "windows" ]; then
            npm run tauri:build:windows
          elif [ "${{ matrix.platform }}" == "macos" ]; then
            npm run tauri:build:macos
          else
            npm run tauri:build:linux
          fi

      - name: Sign bundles (if configured)
        if: matrix.platform == 'windows' && secrets.WINDOWS_SIGNING_CERTIFICATE != ''
        env:
          WINDOWS_SIGNING_CERTIFICATE: ${{ secrets.WINDOWS_SIGNING_CERTIFICATE }}
          WINDOWS_SIGNING_CERTIFICATE_PASSWORD: ${{ secrets.WINDOWS_SIGNING_CERTIFICATE_PASSWORD }}
        shell: pwsh
        run: |
          $certPath = "$env:RUNNER_TEMP\cert.pfx"
          [System.IO.File]::WriteAllBytes($certPath, [System.Convert]::FromBase64String($env:WINDOWS_SIGNING_CERTIFICATE))
          $env:WINDOWS_SIGNING_CERTIFICATE_PATH = $certPath
          $msiFile = Get-ChildItem -Path "src-tauri\target\**\*.msi" | Select-Object -First 1
          if ($msiFile) {
            pwsh scripts/signing/windows-sign.ps1 -MsiPath $msiFile.FullName
          }

      - name: Sign bundles (macOS)
        if: matrix.platform == 'macos' && secrets.MACOS_SIGNING_CERTIFICATE != ''
        env:
          MACOS_SIGNING_CERTIFICATE: ${{ secrets.MACOS_SIGNING_CERTIFICATE }}
          MACOS_SIGNING_CERTIFICATE_PASSWORD: ${{ secrets.MACOS_SIGNING_CERTIFICATE_PASSWORD }}
        run: |
          # macOS signing would go here
          echo "macOS signing not yet implemented"

      - name: Sign update files
        if: secrets.TAURI_SIGNING_KEY != ''
        env:
          TAURI_SIGNING_KEY: ${{ secrets.TAURI_SIGNING_KEY }}
        run: |
          # Set up signing key
          mkdir -p ~/.tauri
          echo "$TAURI_SIGNING_KEY" | base64 -d > ~/.tauri/myapp.key
          chmod 600 ~/.tauri/myapp.key
          
          # Sign bundles
          bash scripts/sign-update-files.sh || echo "Signing failed, continuing..."

      - name: Find and upload release assets
        shell: bash
        run: |
          # Find assets based on platform
          if [ "${{ matrix.platform }}" == "windows" ]; then
            find src-tauri/target -name "*.msi" -o -name "*.msi.sig" | while IFS= read -r asset; do
              if [ -f "$asset" ]; then
                echo "Uploading: $asset"
                gh release upload "${{ needs.prepare-release.outputs.tag }}" "$asset" --repo ${{ github.repository }} || echo "Failed to upload $asset"
              fi
            done
          elif [ "${{ matrix.platform }}" == "macos" ]; then
            find src-tauri/target \( -name "*.dmg" -o -name "*.app.tar.gz" -o -name "*.dmg.sig" -o -name "*.app.tar.gz.sig" \) | while IFS= read -r asset; do
              if [ -f "$asset" ]; then
                echo "Uploading: $asset"
                gh release upload "${{ needs.prepare-release.outputs.tag }}" "$asset" --repo ${{ github.repository }} || echo "Failed to upload $asset"
              fi
            done
          else
            find src-tauri/target \( -name "*.deb" -o -name "*.AppImage.tar.gz" -o -name "*.rpm" -o -name "*.deb.sig" -o -name "*.AppImage.tar.gz.sig" -o -name "*.rpm.sig" \) | while IFS= read -r asset; do
              if [ -f "$asset" ]; then
                echo "Uploading: $asset"
                gh release upload "${{ needs.prepare-release.outputs.tag }}" "$asset" --repo ${{ github.repository }} || echo "Failed to upload $asset"
              fi
            done
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  generate-update-manifest:
    name: Generate Update Manifest
    needs: [prepare-release, build-and-release]
    runs-on: ubuntu-latest
    permissions:
      contents: read
      gists: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install GitHub CLI
        run: |
          type -p curl >/dev/null || apt install curl -y
          curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
          chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg
          echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | tee /etc/apt/sources.list.d/github-cli.list > /dev/null
          apt update
          apt install gh -y

      - name: Get release notes
        id: get_notes
        run: |
          gh release view ${{ needs.prepare-release.outputs.tag }} --repo ${{ github.repository }} --json body --jq '.body' > release_notes.txt || echo "Release ${{ needs.prepare-release.outputs.tag }}" > release_notes.txt
          NOTES=$(cat release_notes.txt)
          echo "notes<<EOF" >> $GITHUB_OUTPUT
          echo "$NOTES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Generate update manifest
        env:
          GITHUB_REPOSITORY: ${{ github.repository }}
          RELEASE_NOTES: ${{ steps.get_notes.outputs.notes }}
        run: |
          node scripts/generate-update-manifest.js latest.json ${{ needs.prepare-release.outputs.version }}
          cat latest.json

      - name: Upload manifest to release
        run: |
          gh release upload "${{ needs.prepare-release.outputs.tag }}" latest.json --repo ${{ github.repository }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create or update Gist with manifest
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          if [ -n "${{ secrets.UPDATE_MANIFEST_GIST_ID }}" ]; then
            echo "Updating existing Gist: ${{ secrets.UPDATE_MANIFEST_GIST_ID }}"
            gh gist edit ${{ secrets.UPDATE_MANIFEST_GIST_ID }} latest.json --filename latest.json
            echo "‚úÖ Updated Gist"
            echo "üìã Manifest URL: https://gist.githubusercontent.com/${{ github.repository_owner }}/${{ secrets.UPDATE_MANIFEST_GIST_ID }}/raw/latest.json"
          else
            echo "Creating new Gist..."
            GIST_OUTPUT=$(gh gist create latest.json --filename latest.json --public)
            GIST_ID=$(echo "$GIST_OUTPUT" | grep -oP 'gist.github.com/[^/]+/\K[^/]+' || echo "")
            if [ -n "$GIST_ID" ]; then
              echo "‚úÖ Created Gist: $GIST_ID"
              echo "üìã Manifest URL: https://gist.githubusercontent.com/${{ github.repository_owner }}/$GIST_ID/raw/latest.json"
              echo ""
              echo "‚ö†Ô∏è  IMPORTANT: Add this to your repository secrets:"
              echo "   Secret name: UPDATE_MANIFEST_GIST_ID"
              echo "   Secret value: $GIST_ID"
            fi
          fi
